AbilityFactory parses differently from the Keyword parser. Your Ability line will look more like a collection of name-value pairs:

`A:<AB/SP/DB/ST>$ <AFSubclass> | <Necessary$ Parameters> | (<Separated$ By> | <Pipes$ Here>) | [Optional$ {Values} [Nested$ Dependency]]`

The ability types are:
- **AB** for Activated Abilities
- **SP** for Spell
- **DB** for Drawback and many abilities that are subsidiary to other things, like replacements. They are only used to chain AFs together, and will never be the root AF
- **ST** for Static, this gets used in case the API should resolve without using the stack<br /> (e.g. the unique *Circling Vultures* special action is directly implemented in the script this way)

Syntax definitions like the above will use different symbols to separate the variable parts from the plaintext:
- angle brackets for mandatory parts
- square brackets for optional parts
- round brackets for grouping parts that are exclusive to each other
- curly brackets to denote the type of a parameter

>*NOTE:*
> - these factories are refactored from time to time (often to adapt to new mechanics), so while some entries could be slightly outdated, the base information should still be correct
> - when in doubt you can always cross-check with the [available APIs](https://github.com/Card-Forge/forge/tree/master/forge-game/src/main/java/forge/game/ability/effects) code
> - a few factories also have _*All_ variants, these are slowly being phased out
> - some parameters are only added for very exotic cards, these won't be included here to keep the focus on understanding the general concepts of scripting
> - a good knowledge of the game rules is often helpful for some of the more complex cases covered

# Common Parameters
*Tip:* the convention is to put most of these before AF-specific params for readability (with the exception of Descriptions better suited at the very end)

## Cost / UnlessCost
`Cost$ {AbilityCost}` is the appropriate way to set the cost of the ability. Currently for spells, any additional costs including the original Mana cost need to appear in the Cost param in the AbilityFactory. For each card that uses it, the order in which the cost is paid will always be the same.

Secondary abilities such as those executed by triggers or replacements (usually) don't need costs. (This is one reason to use DB over AB in these cases.)

Read more about it in [Costs](Costs.md)

## Defined / ValidTgts
Most effects need to know (at least implicitly) which players or objects they're trying to affect. There are two different ways for that:
- `Defined$ {Defined}` if the ability describes on what it's applied
- `ValidTgts$ {Valid}` for abilities that target

Read more about it in [Affected / Targets](Targeting.md)

## Restrictions / Conditions
Restrictions limit when abilities can be put on the stack and Conditions apply during resolving. Typical examples are "Activate only once each turn" or "If this spellâ€™s additional cost was paid, [...]".

Read more about it in [Restriction](Restrictions.md)

## SpellDescription
`SpellDescription$ {String}` is how the text of the ability will display on the card and in the option dialog for cards with multiple abilities.

The SpellDescription for secondary abilities is displayed when (and if) the ability prompts for user input in the prompt pane so it is useful to put some text there or rather split the text into the different effect parts.

## StackDescription
`StackDescription$ {String}` is the description the ability will have on the stack. This is automatically generated by the effect, but may be overridden using this parameter. This is sometimes needed with complex effects, when the generated text can't handle some details. Properties of the spell can be accessed like this: `{c:Targeted}`. You can reuse the spell text by just putting `SpellDescription` or `None` to leave it empty.

## Remember*
Remembering is often needed when a card becomes a new object, which is then further affected by the ability. Typical example: [Flicker](https://github.com/Card-Forge/forge/blob/master/forge-gui/res/cardsfolder/f/flicker.txt)<br />
Because cards keep their remembered parts when changing zones manual [cleanup](#Cleanup) is usually required.

## Duration
> 611.2a. A continuous effect generated by the resolution of a spell or ability lasts as long as stated by the spell or ability creating it (such as "until end of turn"). If no duration is stated, it lasts until the end of the game.

Values:
- EndOfTurn (Default)  
*Note:* since more often an effect only lasts until end of turn this was chosen as default instead of following how the rule defines it
- Permanent
- AsLongAsControl
- AsLongAsInPlay - it really depends on each card's wording if this or the below one is correct, since here *CR 702.26f* defines phasing out as an extra way of ending the effect
- UntilHostLeavesPlay - if the effect should last while the host is still in play
- UntilEndOfCombat
- UntilYourNextTurn

## AI params
* `IsCurse$ True` - for effects that are normally treated positive e.g. Pump

* `AICheckSVar$ {Count}`

* `AILogic$ {String}`

* `AITgts$ BetterThanEvalRating.130`
Normally the AI will only prefer targeting cards that satisfy the constraint. However, you can add `AITgtsStrict$ True` if playing it should only happen when enough of these cards are available, e.g. *Rootwater Matriarch*.

# Factories (in Alphabetical Order)

## Animate
Animate handles animation effects like "This card becomes a 5/5 green creature with flying until end of turn."

Parameters (all optional):
- `Power` - the power to assign to the animated card
- `Toughness` - the toughness to assign to the animated card
- `Types/RemoveTypes` - the types to give to/remove from the animated card; comma delimited
- `RemoveSuperTypes/RemoveCardTypes/RemoveSubTypes$/RemoveCreatureTypes True` - if the animated being should have these types **instead** as opposed to **in addition to**
- `Keywords/RemoveKeywords` - a " & " delimited list of keywords to give to/remove from the animated being
- `Colors` - a comma-delimited list of colors to give to the animated being (capitalized and spelled out)  
  - `ChosenColor` accepted
- `Abilities/Replacements/Triggers/staticAbilities` - a comma-delimited list of SVar names which contain abilities that should be granted to the animated being
- `RemoveAllAbilities` - Remove all Abilities, Triggers, Statics and Replacement effects
- `sVars` - a comma-delimited list of SVars that should be granted to the animated being

## Attach
Attaches a permanent to an affected card or player.

Parameters:
- `Object$ {Defined}` (Default: Self) - This is the Object that will be Attached
- `Choices$ {ValidCard}` - can be used to choose the attachment instead  
can also be combined with `Object` so the choice is for what it should attach to
- `RememberAttached`

Note that Forge's engine handles this automatically for Aura spells, so adding AILogic is a bit different but usually required:

`SVar:AttachAILogic:{String}`
- `Curse/Pump` - A generic Curse/Pump for which the AI has a handful of checks to see if an appropriate target exists
- `GainControl` - Gains control of the attached permanent
- `ChangeType` - For attachments that change types, e.g. *Evil Presence*

## BecomeMonarch
No own parameters.

## Bond
Soulbonding two creatures. Only used internally by the engine.

## Branch
Sometimes, an ability might do certain things when a specific condition is true, and others if not. This can be implemented by using `Branch`.

Parameters:
- `BranchConditionSVar$ {Count}`
- `BranchConditionSVarCompare {comparator}`
- `TrueSubAbility/FalseSubAbility$ {SubAbility}` - executes the specified ability depending on how the condition evaluated

The example below is from *Composer of Spring*, which allows either a "land" or a "land or creature" to be put on the battlefield, depending on the number of enchantments you control:
```
SVar:TrigBranch:DB$ Branch | BranchConditionSVar$ X | BranchConditionSVarCompare$ GE6 | TrueSubAbility$ PutLandCreature | FalseSubAbility$ PutLand
SVar:PutLand:DB$ ChangeZone | Origin$ Hand | Destination$ Battlefield | Tapped$ True | ChangeType$ Land.YouOwn
SVar:PutLandCreature:DB$ ChangeZone | Origin$ Hand | Destination$ Battlefield | Tapped$ True | ChangeType$ Creature.YouOwn,Land.YouOwn
SVar:X:Count$Valid Enchantment.YouCtrl
```

*Note:* sometimes you could also implement this via standard ability Conditions instead, but that requires careful consideration if the relevant property could be changed by one of the applicable effects.

## Charm
This AF represents modal effects.

Parameters:
- `CharmNum$ {Integer}` (Default: 1) - number of modes to choose
- `MinCharmNum$ {Integer}` (Default: same as CharmNum) - if "up to" allows a variable number
- `Choices$ {SubAbilities}` - a comma delimited list of SVars containing the modes

## Choices
AF in this group let the player make choices from all kinds of categories and are often used to chain effects together. However, for common cases many effects already support this directly, e.g. `PutCounter | Choices$`.  
Besides making the script more concise using such shortcuts usually also helps the AI making better use of the effect.

### ChooseCard

### NameCard

### ChooseColor

### ChooseGeneric

### ChooseNumber

### ChoosePlayer

### ChooseType
This can be used when a player is asked to choose a card (sub)type.

Parameters:
- `Type` - Typically "Card", "Creature" or a few special cases
- `ValidTypes {String}` - alternative to above param to explicitly define the types
- `InvalidTypes$ {String}` (Optional) - used to specify any type that can't be chosen

## Clash
This AF handles clashing.

Parameters:
- `WinSubAbility$` (Optional)
- `OtherwiseSubAbility$` (Optional)

## Cleanup
A non-functional, maintenance AF used for cleaning up certain variables before a spell finishes resolving.

Parameters:
- `ClearRemembered$ True` - clear this card's remembered list. Generally useful for abilities that remember an object, do something to it, then need to forget it once it's done
- `ClearImprinted$ True` - clear the imprinted cards
- `ClearChosenCard$ True` - clear the chosen cards

## Control

### GainControl
Parameters:
- `NewController$ {Defined}` (Default: You)

### ControlExchange

### ControlPlayer

### ControlSpell

## Copies

### Clone

### CopyPermanent
Copies a permanent.

Parameters:
- `NumCopies` (Default: 1) - the number of copies to put onto the battlefield.
- `Keywords` (Optional) - a list of keywords to add to the copies

### CopySpellAbility
Parameters:
- `Num$ {Integer}` (Default: 1)

## Counter
Countering Spells or Abilities.

Parameters:
- `Destination` - send countered spell to: (only applies to Spells; ignored for Abilities)
    - TopDeck

## Counters
Factories to handle counters on cards or players.

### Poison
Poison gives a player the specified number of poison counters.

Parameters:
- `Num$ {Integer}` - the number of poison counters to give

### PutCounter
Put any type of counter on a game object.

Parameters:
- `CounterType` - specifies the type of counter and should appear in all caps
- `CounterNum$ {Integer}` (Default: 1) - how many counters will be put on the chosen card
- `Placer$ {Defined}`
- `ETB$ True` - for ETB counters

### RemoveCounter
Remove any type of counter from a game object.

  - CounterType (required) specifies the type of counter and should
    appear in all caps. It should be one of the values in the Counters
    enum.
  - CounterNum (required) specifies how many counters will be removed
    from the chosen card.
  - UpTo is optional. If an effect states you may remove "up to X
    counters", set this to True.

### Proliferate

### MoveCounters
Used for effects that move counters.

Parameters:
- `Source` - The Source of the counters
- `Defined` - The Destination of the counters
- `CounterType` - The type of counter to move
- `CounterNum` - The number of counters to move

## Damage

### DealDamage
Deal damage to a specified player or permanent.

Parameters:
- `NumDmg$ {Integer}` - amount of damage dealt

### EachDamage

## Debuff
Removing Keywords.

Parameters:
- `Keywords`
- `Duration`

## Destroy
Handles destruction of permanents.

Parameters:
- `NoRegen$ True`

## Effect
Effect is an oddball of the AF family. Where usually AFs have similarities to each other to help with AI use, this one's used for all sorts of continuous effects.

A good example is *High Tide*. It doesn't matter if the Island was in play, if it turned into an Island after the spell resolved, any of that.
```
A:SP$ Effect | Triggers$ IslandTrigger | SpellDescription$ Until end of turn, whenever a player taps an Island for mana, that player adds an additional {U}.
SVar:IslandTrigger:Mode$ TapsForMana | ValidCard$ Island | Execute$ TrigMana | Static$ True | TriggerDescription$ Whenever a player taps an Island for mana, that player adds an additional {U}.
SVar:TrigMana:DB$ Mana | Produced$ U | Amount$ 1 | Defined$ TriggeredActivator
```

Effect is most similar to Token as it creates a pseudo-permanent, except Effect creates in the command zone rather than the battlefield.

Parameters:
- `Abilities,Triggers,ReplacementEffects,StaticAbilities,SVars` - comma separated lists which contain SVars that point to the appropriate type that the Effect will gain. You don't need to put the zone-specific params like EffectZone$ onto these
- `Duration`
- `EffectOwner$ {Defined}`
- `ForgetOnMoved$ {ZoneType}` - gets rid of the effect if all remembered cards have left the affected zone
- `RememberObjects$ {Defined}`
- `Stackable$ False` - most effects are assumed to be stackable. By using this flag, the AI will know having a second one active is (at least mostly) useless, so it will save its resources for something else
- `Name$ {String}` (Optional) - usually auto-generated
- `Image$ filename\without\extension` (Optional) - image needs to reside in the tokens directory

## Explore

## Fight

## FlipACoin

## Fog
This AF is based on the original *Fog* spell: "Prevent all combat damage that would be dealt this turn." While this could be done with an Effect, the specialized nature of the AI gives it its own AF.

## GainLife / LoseLife / SetLife
Have a player gain or lose the specified amount of life.

Parameters:
- `LifeAmount$ {Integer}` - the value to modify the life total(s)

## Game outcome

### GameDraw

### GameLoss

### GameWin

### RestartGame
Used in the script of *Karn Liberated*.

## Goad

## Loops
Repeat the specified ability.

### Repeat
Parameters:
- `MaxRepeat` - optional - the maximum times to repeat, execute repeat ability at least once
- `RepeatSubAbility` - setup subability to repeat
- `RepeatOptional$ True` - you make the choice whether to repeat the process
- RepeatPresent, RepeatCompare, RepeatDefined, RepeatCheckSVar, RepeatSVarCompare - optional - condition check

### RepeatEach
A more complex variant that iterates over objects of some type instead. During each `RepeatSubAbility` execution the current object is remembered.

Parameters:
- `RepeatSubAbility` - required - to set up repeat subability
- `RepeatCards` - to repeat for each valid card (zone: present zone of the valid repeat cards, default: battlefield)
- `DefinedCards`
- `RepeatPlayers` - to repeat for each valid player
- `RepeatCounters` - to repeat for each valid counters

## Mana
Add mana to a player's mana pool.

Parameters:
- `Produced$ {String}`

## Manifest / Cloak

## Permanent State
AF for effects that alter a permanent's state.

### Phases

### SetState
Changing a cards state. This is mostly for Flip Cards or the Transform mechanic.

### Tap

### TapOrUntap

### Untap

## Play
Playing cards as part of another ability. The player may have to make a choice about which card to play if there are more choices than the number of cards to play.

Parameters:
- `Amount$ {Integer/All}` (Default: 1) - how many cards can be played
- `Valid` - selection criteria for valid cards from the zone to cast
- `ValidSA` - applied after Valid, this will filter based on all spells of the cards
- `ValidZone` - the zone to look in to determine the valid cards
- `Optional$ True` - playing is optional
- `RememberPlayed$ True` - remember the card played
- `PlayCost$ {AbilityCost}`
- `WithoutManaCost$ True` - The card can be cast without its normal mana cost
- `Controller$ {Defined}` (Default: You) - controller of the ability

## PreventDamage

## Protection
Grants protection from traits like colors or card types.

Parameters:
- `Gains` - the thing to gain protection from (green, artifacts, Demons, etc.) or "Choice" if you can choose one of a comma-delimited list of `Choices$`

## Pump
Handles pumping creatures power/toughness or granting keywords to cards or players.

Parameters (all optional):
- `NumAtt$` - pumps Power
- `NumDef$` - pumps Toughness
- `KW$` - gives keywords

Due to its generic nature Pump is also the conventional "helper AF" when an effect requires more than one target with different restrictions, e.g. *Political Trickery*:
```
A:SP$ Pump | ValidTgts$ Land.YouCtrl | TgtPrompt$ Choose target land you control | SubAbility$ DBExchange | SpellDescription$ Exchange control of target land you control and target land an opponent controls. (This effect lasts indefinitely.)
SVar:DBExchange:DB$ ExchangeControl | Defined$ ParentTarget | ValidTgts$ Land.OppCtrl | TgtPrompt$ Choose target land an opponent controls
```

## Regenerate
Creating regeneration shields.

## Reveal

### RevealHand
Look at a player's hand.

### Reveal
Parameters:
- `RevealValid` to limit the valid cards
- `AnyNumber`
- `Random`
- `RememberRevealed` to remember the cards revealed

### PeekAndReveal
This AF is very similar to things that Dig can do, but handle a much simpler form, with less complex coding underneath. Similar to how RearrangeTopOfLibrary could be handled with Dig.

Primarily used with cards that allow you to Peek at the top card of your library, and allow you to reveal it if it's of a certain type. The Kinship cards fit this bill perfectly, so they are used to simplify the complex popups that would be required if using multiple Dig SubAbilities.

Parameters:
- `RevealOptional` - Whether or not the Reveal is optional.
- `RememberRevealed` - Whether to remember the revealed cards (after filtering by Valid)
- `RememberPeeked` - Whether to remember the peeked cards (only if they are not revealed\!)
- `RevealValid` - defaults to Card, but allows you to set a specific ValidType if you can only have certain things
- `PeekAmount` - defaults to 1, but allows you to peek at multiple cards if possible

## RollDice

## Sacrifice
Forces a player to sacrifice something of their choice.

Parameters:
- `SacValid$ {ValidCard}` (Default: Card.Self)

## Scry

## Surveil

## StoreSVar

## Tokens

### Amass

### Investigate

### Token
Token lets you create tokens of any type. They get defined by creating scripts in the `res/tokenscripts` folder.

Parameters:
- `TokenScript$ {filename[,filename]}` - list of tokens to create
- `TokenAmount$ {Integer}` (Default: 1)
- `TokenOwner$ {DefinedPlayer}` (Default: You)

## Triggers
If possible split the SpellDescription of the effect so the part for the trigger can become the StackDescription directly.

### DelayedTrigger
The trigger-specific params are defined in [Triggers](Triggers.md).

### ImmediateTrigger
Parameters:
- `TriggerAmount$ {Integer}` (Default: 1)

## Turn structure

### AddPhase

### AddTurn

### EndTurn

### ReverseTurnOrder
No own parameters.

### SkipPhase

### SkipTurn

## Vote

## Zone Affecting
For effects that modify zones in a specific manner.

### ChangeZone
ChangeZone is a united front of any card that changes zone. This does not include: drawing, destroying, etc. as these represent specific words on which triggers and replacements can react.

Two primary forms are available after setting these parameters, depending on how the effect is templated:
- `Origin$ {ZoneType}` is where the card is coming from
- `Destination$ {ZoneType}` is where the card is going to
- `LibraryPosition {Integer}` (Default: 0) - ignored when not moving to library. 0 represents the top, -1 the bottom

**Hidden syntax**

Hidden is generally used for origin zones that are not known information, e.g. the Library. The choice of "What card is changing zones?" happens during resolution. **If you need this for public zones `Hidden$ True` is required.**

Example (*Call the Gatewatch*):  
`A:SP$ ChangeZone | Origin$ Library | Destination$ Hand | ChangeType$ Planeswalker | SpellDescription$ Search your library for a planeswalker card, reveal it, put it into your hand, then shuffle.`

Parameters:
- `ChangeType$ {ValidCard}`
- `ChangeNum$ {Integer}`
- `Chooser$ {DefinedPlayer} -` which player decides which card changes zone
- `Mandatory$ True` - most of these abilities aren't mandatory, but **CR 701.23d.** means cards like *Demonic Tutor* are different

**Known syntax**

The second is known, instead designed for origin zones that are known information, like the battlefield. The choice of "What card is changing zones?" happens when it's put on the stack (or is at least fixed some other way).

Example (**Excommunicate**):  
`A:SP$ ChangeZone | ValidTgts$ Creature | Origin$ Battlefield | Destination$ Library | LibraryPosition$ 0 | SpellDescription$ Put target creature on top of its owner's library.`

### ChangeZoneResolve
This is a helper AF, for chained effects that create multiple permanents which should enter the battlefield at the same time.

To use it, you need to set the param `ChangeZoneTable$ True` on the first effect and then call this at the end.

This is supported by the following effects:
- Amass
- CopyPermanent
- RepeatEach (_NOTE: if you wrap the creation, you don't need to call this AF on its own_)
- Token

### Dig
Dig is for an ability that does basically this: "You look at the X cards of your Library, put Y of them somewhere, then put the rest somewhere."

Parameters:
- `DigNum$ {Integer}` - look at the top X number of cards
- `Reveal$ True` (Default: False)
- `ChangeNum$ {Integer/Any/All}` (Default: 1)
  - the number of cards to move to the DestinationZone
  - "Any" if you can move any number of Cards to DestinationZone
  - "All" when it's for things like "put all lands revealed this way into your hand"
- `ChangeValid$ {ValidCard}` (Default: Card) - use this to specify if only certain types can be moved to DestinationZone
- `Optional$ True` (Default: False) - if you "may" move a card to DestinationZone
- `SourceZone$ {ZoneType}` (Default: Library) - the zone to dig in
- `DestinationZone$ {ZoneType}` (Default: Hand) - the zone to put the Y cards in
- `DestinationZone2$ {ZoneType}` (Default: Library) - the zone to put the rest in
- `LibraryPosition/LibraryPosition2 {Integer}` (Default: -1) - if DestinationZone is Library, use this to specify position

### DigUntil

### Discard
Parameters:
- `NumCards$ {Integer}` (Default: 1) - the number of cards to discard
- `Mode$ {String}` - the mode of discard
  - Random
  - TgtChoose
  - RevealYouChoose
  - Hand
- `DiscardValid$ {ValidCard}` (Default: Card) - acceptable cards to discard
- `UnlessType$ {ValidCard}` - expression for "discard X unless you discard valid"

### Draw
Parameters:
- `NumCards$ {Integer}` (Default: 1) - the number of cards to draw

### Mill
Parameters:
- `NumCards$ {Integer}` (Default: 1) - the number of cards to mill

### RearrangeTopOfLibrary

### Shuffle
Used for shuffling a player's library.

Parameters:
- `Optional$ True` - if the activator gets to decide if each affected player shuffles

### TwoPiles

A reference guide for scripting cards using the API parsed by the Forge engine.

# Base Structure
By opening any file in the */res/cardsfolder* directory you can see the basic structure of how the data is created.  
Here's an example of a vanilla creature:
```
Name:Vanilla Creature
ManaCost:2 G
Types:Creature Beast
PT:2/2
Oracle:
```

* The name of this card is Vanilla Creature.
* It's casting cost is {2}{G}.
* It has the types Creature and Beast.
* It has a Power-Toughness of 2/2.
* It will not display any additional text in the card's template.

If a card has two faces, use AlternateMode:{CardStateName} in the front face and separate both by a new line with the text `ALTERNATE`.

There are a few other properties that will appear in many cards. These can all be used across different faces - with `AI` and related `Deck`-variants being the exception:

| Property | Description
| - | -
|`A`|[Ability effect](AbilityFactory.md)
|`AI`|`RemoveDeck:`<br />* `All`<br />This will prevent the card from appearing in random AI decks. It is applicable for cards the AI can't use at all and also for cards that the AI could use, but only ineffectively. The AI won't draft these cards.<br />* `Random`<br /> This will prevent the card from appearing in random decks. It is only applicable for cards that are too narrow for random decks like *Root Cage* or *Into the North*. The AI won't draft these cards.<br />* `NonCommander`<br />
|`Colors`|Color(s) of the card<br /><br />When a card's color is determined by a color indicator rather than shards in a mana cost, this property must be defined. If no identifier is needed, this property should be omitted.<br /><br />Example:<br />`Colors:red,green` - Since *Arlinn, Embraced by the Moon* has no mana cost (it's the back of a double-faced card), the red and green indicator must be included.
|`DeckHints`|AI-related hints for a deck including this card<br /><br />To improve synergy this will increase the rank of of all other cards that share some of its DeckHints types. The following types are supported:<br />* Color<br />* Keyword<br />* Name<br />* Type<br /><br />This helps with smoothing the selection so cards without these Entries won't be at an unfair disadvantage.<br /><br />The relevant code can be found in the [CardRanker](https://github.com/Card-Forge/forge/blob/master/forge-gui/src/main/java/forge/gamemodes/limited/CardRanker.java) class.
|`DeckNeeds`|This can be considered a stronger variant when the AI should not put this card into its deck unless it has whatever other type is specified. The way this works is "inverted": it will directly decrease the rank of the card unless other cards are able to satisfy its types.<br />If a card demands more than one kind of type you can reuse it:<br />`DeckNeeds:Type$Human & Type$Warrior` will only find Human Warrior compared to `DeckNeeds:Type$Human\|Warrior` which is either
|`DeckHas`|Specifies that the deck now has a certain ability (like, token generation) so that the drafting/deckbuilding AI knows that it now meets requirements for DeckHints/DeckNeeds. This is useful since many of these are not deduced by parsing the abilities, so an explicit hint is necessary. If you want to create a new archetype make sure to tag at least roughly 50 cards to start with and balacing the Has/Needs ratio. Currently used values are:<br />* Counters<br />* Graveyard<br />* Token<br /><br />Using the generic types is also supported in case the implicit parsing wouldn't find it (TokenScript$ is also included).<br />It doesn't require exact matching to have an effect but cards that care about multiple entries for a given type will be judged higher if a card seems to provide even "more" synergy for it.<br /><br />Example:<br />*Chishiro* has two abilities so `DeckHas:Ability$Token & Ability$Counters` is used, therefore score for `DeckNeeds:Ability$Token\|Counters` is increased
|`K`|Keyword (see below)
|`Loyalty`|Number of starting loyalty counters
|`ManaCost`|Cost to cast the card shown in mana shards<br /><br />This property is required. It has a single parameter that is a mana cost.<br /><br />* `ManaCost:no cost` for cards that cannot be cast<br />* `ManaCost:1 W W` sets the casting cost to {1}{W}{W}
|`Name`|Name of the card<br /><br />A string of text that serves as the name of the card. Note that the registered trademark symbol cannot be included, and this property must have at least one character.
|`Oracle`|The current Oracle text used by the card.<br /><br />We actually have a Python Script that runs to be able to fill in this information, so don't worry about manually editing a lot of cards when Wizards decides to change the rules. <br /><br />This field is used by the Deck Editor to allow non-Legendary Creatures to be marked as potential commanders. Make sure "CARDNAME can be your commander." appears in the oracle text.
|`PT`|Power and toughness
|`R`|[Replacement effect](Replacements.md)
|`S`|[Static ability](Statics.md)
|`SVar`|String variable. Used throughout scripting in a handful of different ways.
|`T`|[Triggered ability](Triggers.md)
|`Text`|Additional text that needs to be displayed on the CardDetailPanel that doesn't have any spell/ability that generates a description for it, e.g. "CARDNAME can be your commander." or "X can't be 0.".
|`Types`|Card types and subtypes<br /><br />Include all card types and subtypes, separated by spaces.<br /><br />Example:<br />`Types:Enchantment Artifact Creature Golem` for a card that reads "Enchantment Artifact Creature -- Golem"

Metadata like rarity gets placed in edition definition files. These can be found at */res/editions* path.

## Conventions
- filename: all lowercase, skip special characters, underscore for spaces
- Unix(LF) line endings
- use empty lines only when separating multiple faces on a card
- AI SVars right before the Oracle
- try to avoid writing default params to keep scripts concise
  - e.g. just `SP$ Draw` instead of `SP$ Draw | Defined$ You | NumCards$ 1`

# Keywords
All keywords need to be prepended with "K:" to be parsed correctly. Each keyword must appear on a separate line.

## Keywords without Parameters
This section is for Keywords that require no additional parameters and are one or two words long. Most of these you would see exactly on cards in the game.  
Examples:
- Cascade
- Cipher
- Convoke
- Devoid
- First Strike
- Flash
- Haste
- Indestructible
- Mentor
- Provoke
- Reach
- Split second
- Trample
- Undying
- Vigilance
- Wither

## Keywords with parameters
- Adapt:{cost}
- Afterlife:{N}
- AlternateAdditionalCost:{cost}
- Amplify:{cost}:{validType(comma separated)}
- Annihilator:{magnitude}
- Bloodthirst:{magnitude}
- Bestow:{cost}
- Bushido:{magnitude}
- Champion:{validType}
- Crew:{cost}
- Cumulative upkeep:{cost}:{Description}
- Cycling:{cost}
- Dash:{cost}
- Devour:{magnitude}
- Dredge:{magnitude}
- Echo:{cost}
- Emerge:{cost}
- Enchant:{Type}
- Entwine:{cost}
- Equip:{cost}
- Evoke:{cost}
- Fabricate:{cost}
- Fading:{FadeCounters}
- Flashback:{cost}
- Foretell:{cost}
- Fortify:{cost}
- Graft:{value}
- Haunt:{ability}:<Ability>
- Hexproof:{ValidCards}:[Description]
- Kicker:{cost}
- Level up:{cost}
- Madness:{cost}
- MayEffectFromOpeningHand:{Effect}
- Miracle:{cost}
- Modular:{magnitude}
- Monstrosity:{cost}
- [Mega]Morph:{cost}
- Multikicker:{magnitude}
- Mutate:{cost}
- Ninjutsu:{cost}
- Outlast:{cost}
- Partner:{CardName}
- Protection:{ValidCards}:{Description}
- Prowl:{cost}
- Rampage:{magnitude}
- Recover:{cost}
- Renown:{N}
- Replicate:{cost}
- Ripple:{magnitude}
- Soulshift:{magnitude}
- Strive:{cost}
- Suspend:{turns}:{cost}
- Transmute:{cost}
- Toxic:{poisonCounters}
- TypeCycling:{Type}:{cost}
- Unearth:{cost}
- Vanishing:{TimeCounters}

## Plaintext keywords
These are hardcoded but not truly keywords rules-wise and will eventually be turned into static abilities.
Only listing the most common ones here so you can recognize them.
CARDNAME is replaced by the card's name ingame.

- CARDNAME can't attack or block alone.
- CARDNAME can't block unless a creature with greater power also blocks.
- CARDNAME must be blocked if able.
- Remove CARDNAME from your deck before playing if you're not playing for ante.
- You may choose not to untap CARDNAME during your untap step.
- CantSearchLibrary

# General SVars
* `SoundEffect:<file.mp3>`

The sound system supports a special SVar that defines the sound that should be played when the spell is cast.

* `<Name>:Count$<Parameters>`

Count is our general value computation function. It's quite varied with a lot of different things it can calculate and is often being updated. There are way too many parameters that introducing all here doesn't really help. Refer to the `AbilityUtils.xCount` method in the code if you're looking for a specific case.

Here are some often used examples to illustrate the basic ideas:
>`SVar:X:Count$ValidGraveyard,Exile Instant.YouOwn,Sorcery.YouOwn`  
number of instant and sorcery cards you own in exile and in your graveyard

>`SVar:X:Count$xPaid`  
used for effects with X in their costs

# Common AI specific SVars
* `AIEvaluationModifier:{ValidAmount}`

* `AIPreference:SacCost$Creature.token,Creature.cmcLE2`

* `AntiBuffedBy:{ValidCards}`

If a permanent with this SVar is on the battlefield under human control the AI will play the specified cards in Main1. Applicable for cards like *Timid Drake*.

* `BuffedBy:{ValidCards}`

If a permanent with this SVar is on the battlefield under its control the AI will play the specified cards in Main1. Applicable for creatures with a P/T setting static ability (e.g. *Kithkin Rabble*) or additional buffs (*Abzan Runemark*).

* `EnchantMe:{Multiple/Once}`

Creatures with "Multiple" in this SVar will always be preferred when the AI enchants (e.g *Rabid Wombat*), creatures with "Once" only if they are not enchanted already.

* `EquipMe:{Multiple/Once>}`

Creatures with "Multiple" in this SVar will always be preferred when the AI equips, creatures with "Once" only if they are not equipped already.

* `EndOfTurnLeavePlay:True`

* `HasCombatEffect:True`

* `HasAttackEffect:True`

* `HasBlockEffect:True`

* `MustAttack:True`

* `MustBeBlocked:True`

* `ManaNeededToAvoidNegativeEffect:`

* `NeedsToPlayVar:{SVar or #} {cmp}`

Put this on cards that are very situational.

Uses operand-operator syntax, where `{cmp}` is a comparator:  
**LT** *Less Than*  
**LE** *Less than or Equal*  
**EQ** *EQual*  
**NE** *Not Equal*  
**GE** *Greater than or Equal*  
**GT** *Greater Than*  

*Tip:* the AI is (usually) smart enough to not play permanents if they have obviously ineffective ETB triggers.

Here's a good example from *Eldrazi Monument* where the extra heuristics try to avoid playing it without a good enough boardstate:
```
SVar:NeedsToPlayVar:Y GE3
SVar:Y:Count$Valid Creature.YouCtrl
```

* `NonStackingEffect:True`

* `NoZeroToughnessAI:True`

* `PlayMain1:{TRUE/OPPONENTCREATURES/ALWAYS}`

The AI will play permanents with this SVar in its first main phase. For some more common mechanics the AI performs its own checks, e.g. to get Backup abilities on an attacker. But for complex cases without own AILogic, it will usually hold them until Main2 to save mana for combat tricks.  
For other spells only "ALWAYS" is supported.

* `SacMe:{1-6}`

The AI will sacrifice these cards to pay costs. The higher the number the higher the priority. Example: *Hatching Plans* has `SVar:SacMe:5`.

* `Targeting:Dies`

* `UntapMe:True`

The AI will prioritize untapping of this card.

Cost is a class that attempts to streamline costs throughout all cards. It requires that each cost is separated by a space. They can generally be found on every Ability, although certain Keyworded abilities do use Cost too.

# CostDesc / PrecostDesc

# UnlessCost
`UnlessCost$ <AbilityCost>` allows a player to pay costs to prevent the resolving of the ability.

Add `UnlessPayer$ <Defined>` for changing which players are included, defaults to "TargetedController".

If the script has the param `UnlessSwitched$ <Defined>`, then the player pays mana to resolve the ability (usually used to handle "any player may pay ..." ).

# Types of Cost
The base syntax for more complex parts looks like this:  
`Part<Integer[/Type][/TypeDescription]>`

Type is often a `Valid` property or `CARDNAME / NICKNAME` for Costs that do something to themselves (e.g. Sacrifice Self).

Description is the last parameter in the cost. This is to allow for complex Type definitions to have a better readable text.

## Discard
`Discard<Num/Type/Description>`

- The first is how many cards are being discarded
- The second is what card types can be discarded
  - "Hand" for the whole hand
  - "Random" for chosen randomly

Examples:
- `Discard<0/Hand>` (The number is ignored here)
- `Discard<1/Creature.Black/black Creature>`

## Draw

## Exile
`Exile<Num/Type/Description>`

There are also a few sister abilities that all fit under the Exile umbrella:
- Exile (for cards on the Battlefield)
- ExileFromGraveyard
- ExileFromHand
- ExileFromTop

Examples:
- `Exile<1/CARDNAME>`
- `ExileFromGrave<1/Treefolk>`
- `ExileFromTop<10/Card>`

## FlipCoin
Only used by *Karplusan Minotaur*.

## Mana
For normal mana costs you can just write the shards directly like printed.

Examples:
- `Cost$ C` - 1 colorless mana
- `Cost$ B R` - 1 black and 1 red mana
- `Cost$ WG` - Hybrid White/Green mana
- `Cost$ S` - Snow mana
- `Cost$ Mana<2\Creature>` - 2 generic mana produced by a source with type 'creature'. Note the backslash, it was chosen because hybrid costs already use slash

## Mill

## PayEnergy

## PayLife
`PayLife<Num>`

## Return
`Return<Num/Type/Description>`

## Reveal

## Sacrifice

## Sub(tract) Counter
`SubCounter<Num/CounterName>`

- `SubCounter<1/CHARGE>`

Remember the countertype should appear all in caps.

## Tap / Untap
`Cost$ T`

`Cost$ Q`

## TapXType

## Unattach

This page covers how to create replacement effects.  
The base syntax looks like this:

`R:Event$ <ReplacementType> | <Type-specific params> | [Description$ {String}]`

- `ReplacementType` is the event being replaced
- Most replacement effects will also have a `ReplaceWith$` parameter which points to an SVar which contains the subability that should replace the event
- `Layer$ {CantHappen/Control/Copy/Transform}` is optional and needs to be set if the effect is ordered to happen before others. <br />Notable `CantHappen` is Forge's way to handle [CR 614.17](https://yawgatog.com/resources/magic-rules/#R61417), though not available for every replacement since some are also implemented as [Statics](Statics.md) instead

Similarly to triggers, the replacing code can access special variables pertaining to the event it replaced. These are specific to each event, and the most common ones are listed below.

# AddCounter

# BeginPhase / BeginTurn

# CreateToken

# DamageDone
This event gets checked when damage is about to be assigned to a card or player.

They may have a `Prevent$ True` parameter instead of an `Execute$` though, which means that nothing happens instead of the event.

Parameters:
- `ValidSource` - The damage source must match this for the event to be replaced
- `ValidTarget` - The damage target must match this for the event to be replaced
- `DamageAmount` - The amount of damage must match this
- `IsCombat` - If true, the damage must be combat damage, if false, it can't be

ReplacedObjects:
- `DamageAmount` - The amount of damage to be assigned
- `Target` - The target of the damage
- `Source` - The source of the damage

# Destroy

# Discard
This event gets checked when a player is about to discard a card.

Parameters:
- `ValidPlayer` - The player who would discard must match this
- `ValidCard` - The card that would be discarded must match this
- `ValidSource` - The card causing the discard must match this
- DiscardFromEffect - If true, only discards caused by spells/effects will be replaced. Cleanup/statebased discards will not.

ReplacedObjects:
- `Card` - The card that would be discarded
- `Player` - The player that would have discarded

# Draw
This events gets checked when a player is about to draw a card.

Parameters:
- `ValidPlayer` - The player who would draw must match this

# GainLife
This events gets checked when a player would gain life.

Parameters:
- `ValidPlayer` - The player who would gain life must match this

# GameLoss
This event gets checked when a player would lose.

Parameters:
- `ValidPlayer` - The player who would lose must match this

# LoseMana

# ProduceMana

# Moved
This event gets checked when a card would be moved between zones.

Parameters:
- `ValidCard` - The moving card must match this
- `Origin` - The card must be moving from this zone
- `Destination` - The card must be moving to this zone

ReplacedObjects:
- `Card` - The moving card

# Untap
# Restrictions

## `Activation$ {Option}`
This can accept several different values which basically follow the text of the card:
- Metalcraft
- Threshold
- Hellbent

## ActivationLimit
`[Game]ActivationLimit$ {Integer}` for cards that have a limited amount of uses per game/turn.

## ActivationPhases
`ActivationPhases$ {PhaseType[,PhaseType,...]}` for abilities that can only be activated during certain phases.

This can also be handled in a range, e.g.:  
`ActivationPhases$ BeginCombat->EndCombat` for abilities that can only be played during combat.

## ActivationZone
`ActivationZone$ {ZoneType}` for cards that have abilities that you can activate outside of the Battlefield.

## OpponentTurn
`OpponentTurn $True` for cards that can only be activated during the opponent's turn of the activating player.

## PlayerTurn
`PlayerTurn $True` for cards that can only be activated during the activating player's turn.

## Planeswalker
`Planeswalker$ True` for Planeswalker abilities.

Add `Ultimate$ True` when applicable for the AI and achievements.

## SorcerySpeed
`SorcerySpeed $True` for cards that can only activate if you could cast a sorcery.

## CheckSVar
CheckSVar specifies that the results computed from an SVar must be evaluated against a certain value which you can specify in the accompanying `SVarCompare$ {cmp}{SVar}` parameter.  
If SVarCompare is **missing**, the comparator defaults to `GE1`.

## IsPresent
`IsPresent$ {ValidCards}` can be considered a shortcut to check if specific cards exist in a zone.

# Conditions
Condition is similar to a restriction, except it's checked on Resolution of the spell and not on Activation.
There are two major groups of static abilities:

# Statics for the main 7 layers
Syntax:  
`S:Mode$ <Continuous> | <Affected$ {Valid Player/Card}> | [AffectedZone$ {ZoneType}] | [EffectZone$ {ZoneType}] | <Layer-specific$ Params> | [Description$ {String}]`

By default `Affected-/EffectZone` are both Battlefield.  
*Tip:* Use "All" as shortcut if it's supposed to affect (or work in) every zone.

Here's an example for layer 7c:  
`Affected$ Creature.YouCtrl | AddPower$ 1 | AddToughness$ 1 | Description$ Creatures you control get +1/+1.`

`CharacteristicDefining$ True`

See [StaticAbility.generateLayer()](https://github.com/Card-Forge/forge/blob/master/forge-game/src/main/java/forge/game/staticability/StaticAbility.java) for the full list of params on each Layer.

*Note:* Layer 1 is currently only implemented as a resolving effect instead.

# Statics for the concluding "game rules layer" ([CR 613.11](https://yawgatog.com/resources/magic-rules/#R61311))
All available effects are defined here: [StaticAbilityMode](https://github.com/Card-Forge/forge/blob/master/forge-game/src/main/java/forge/game/staticability/StaticAbilityMode.java).

*Note:* some rules-modifying parts are still coded via `Continuous` mode for now, e.g. `SetMaxHandSize$ {Integer}`.

The more frequent or complicated ones are presented below:

## CantBeCast / CantBeActivated / CantPlayLand

## CantGainLife / CantLoseLife / CantChangeLife / CantPayLife

## Combat legality

### CantAttack / CantBlock

### MustAttack / MustBlock

## DisableTriggers

## Costs

### AlternativeCost

### CantAttackUnless / CantBlockUnless

### OptionalCost

### OptionalAttackCost

### RaiseCost / ReduceCost / SetCost

## Panharmonicon
This is named after the first card printed with this ability.

# Affected
A `Defined` parameter states what is receiving the action. Remember this is non-targeted!

To combine multiple entities use `&`.
Example: `Defined$ Valid Creature & Player`

You can combine Defined with Valid Syntax (explained in the [Targets](#Targets) section) like so:
`{Defined}.{Valid}`

*Note:* Sometimes you might still use both on a single effect if it's affecting more than its targets, e.g. *Flumph*. 

## Defined Players
Defined Players are for SAs like "Draw" or "GainLife".

### You
The most common of these is `Defined$ You`. It means exactly what one can expect: "You draw/learn/...".

This is also the default value. But it's important to include this in SAs that have an unclear "Default" value such as Damage.

### Opponent
This means "Deals damage to each opponent" or "Each opponent discards."

### Player
Each player.

### TargetedController / TargetedOwner

### AttackingPlayer / DefendingPlayer

## Defined Cards
Defined Cards are for SAs like "Pump" or "Regenerate".

### Self
The most common of these is `Defined$ Self`. It means exactly what one can expect: "This creature gains flying" or "Regenerate this creature."

This is also the default value. Again it's important to include this in SAs that have an unclear "Default" value.

### Enchanted
Enchanted is often needed on Auras. It means "do this action to the card I'm Enchanted to".

### Remembered

### Valid
Example: *No Rest for the Wicked* and the like would use  
`AB$ ChangeZone | Origin$ Graveyard | Destination$ Hand | Defined$ ValidGraveyard Creature.YouOwn+ThisTurnEnteredFrom_Battlefield | SpellDescription$ Return to your hand all creature cards in your graveyard that were put there from the battlefield this turn.`

### Targeted
Targeted will usually appear on a SubAbility. It means "Do this action to whatever a parent Ability targeted".

That may sound confusing so here's how an example:
```
SP$ Untap | ValidTgts$ Creature | SubAbility$ DBPump | SpellDescription$ Untap target Creature. It gains +1/+1 until end of turn.
SVar:DBPump:DB$ Pump | Defined$ Targeted | NumAtt$ +1 | NumDef$ +1
```

# Targets
Each element follows the form:
`<{CardType/PlayerType}>[{.restriction}{+furtherRestriction}]`

CardType may be any type, generally the supertypes like `Creature`, `Artifact`, etc. However, it could also be `Elf` or `Goblin` - though that would also include Elf Enchantments.  
To specify an "Elf Creature", then it should be `Creature.Elf`. `Permanent` represents any permanent, `Card` any card.  
All restrictions can be negated by prefixing them with a `!`.

Try to be precise with your restrictions, e.g. just `Elf` instead of `Card.Elf` etc. The engine will thank you!

Some common restrictions other than types/colors that are interpreted: (case sensitive)
* `named{String}`
* `ChosenCard/ChosenType`  
For cards that were chosen with ChooseCard/Type API. 
* `Colorless/Multicolor`
* `YouCtrl/YouOwn`
* `Other/Self`
* `AttachedBy/Attached`
* `DamagedBy/Damaged`
* `with{Keyword}`
* `tapped/untapped`
* `faceDown`
* `token`
* `attacking/blocking`
* `IsRemembered`
* `power/toughness/cmc{cmp}{SVar or #}`
* `counters{cmp}{SVar or #}{Type}`

Examples:
* "Artifact or Enchantment" would be represented as 2 elements `Artifact,Enchantment`
* "non-black, non-artifact creature" would be represented as `Creature.!Black+!Artifact`
* "creature with flying" is `Creature.withFlying`
* "creature with four or more level counters" is `Creature.countersGE4LEVEL`

For the full list of all available properties see the classes [CardProperty](https://github.com/Card-Forge/forge/blob/master/forge-game/src/main/java/forge/game/card/CardProperty.java) or respectively [PlayerProperty](https://github.com/Card-Forge/forge/blob/master/forge-game/src/main/java/forge/game/player/PlayerProperty.java).

## TgtZone$ {ZoneType}
Redundant for AF that can only target the Stack or where the specified zone already matches with a `Origin$` parameter.

## TargetType

## TgtPrompt$ {String}
Auto-generated, so try to avoid them when only targeting single word restrictions.  
Example: `TgtPrompt$ Select target creature that entered this turn`

## TargetingPlayer$ {Defined}
Some older cards let a different player than the activator choose the target.

Triggers define when an ability should be automatically added to the stack.

The base syntax looks like this:
`T:Mode$ <TriggerType> | <Type-specific params> | [TriggerDescription$ {String}]`

- `Mode` - Specifies what game event the trigger should wait for
- `Execute` - Specifies the name of the SVar that holds the ability to run when the trigger goes off
- `TriggerDescription` - Describes the trigger, much like AF's SpellDescription parameter

Optional parameters that triggers can use are:
- `Secondary$ True` - This means that its trigger description won't show up in a card's text box. This can be used if you need to use several triggers to emulate a single effect on a real card
- `Static$ True` - This is mainly used for "As CARDNAME enters the battlefield..." type things. It causes the triggered ability to resolve right away, instead of going on the stack
- `ResolvingCheck`
- `NoResolvingCheck$ True` - Makes a trigger not recheck its condition to resolve
- `OptionalDecider {DefinedPlayer}`
- `TriggerZones {ZoneType}` - By default triggers work in all zones. This parameter can be used to restrict which zone the card must be in, in order for the trigger to go off. For example, if it should only go off while the card is in the graveyard (as in *Auntie's Snitch*) you can use `TriggerZones$ Graveyard`. If a trigger's condition instead only applies to itself it's usually not required to explicitly add this since most events can only happen for cards in a single specific zone anyway.

You can use certain parameters to further restrict when a trigger should go off. These parameters are defined in [Restrictions](Restrictions.md).

In addition, the script has access to many values that are relevant to the trigger context.  
These are accessed via Triggered-variables and are always of the form `Triggered<Object Name>`.  
You can use Triggered-variables that return a card or a player directly in `Defined$` parameters or to grab extra info from, e.g. `SVar:X:TriggeredCard$CardPower`.
You can get the controller or owner of a card returned by a Triggered-variable by appending "Controller" or "Owner" to the variable.
Triggered-variables that return an integer can be accessed from their own Count-subfunction, i.e. `SVar:X:TriggerCount$TriggeredLifeAmount`.

Depending on which Mode is specified, different Triggered-variables are available and other parameters may be expected.  
A few modes also have "Once" variants to handle "One or more" conditions.  
Below are the currently available modes.

# Always
Always-triggers represent State triggers, a special kind of triggers with their own rule ([CR 603.8](https://yawgatog.com/resources/magic-rules/#R6038)).

# Attached / Unattach
Goes off when a card becomes attached, via enchanting or equipping, to another card or player.

Parameters:
- `ValidSource` - The card that is being attached to another must match this for the trigger to go off
- `ValidTarget` - The card that is having another card attached to it must match this

TriggeredObjects:
- `Source` - The card that is being attached
- `Target` - The card that is being attached to

# BecomeMonstrous
Goes off when a creature becomes Monstrous.

Parameters:
- `ValidCard` - The card that becomes monstrous must match this

TriggeredObjects:
- `Card` - The card that became monstrous

# BecomesTarget
BecomesTarget-triggers go off when a spell or ability (or either) is put on the stack targeting something.

Parameters:
- `ValidSource` - The card that targets something must match this
- `ValidTarget` - The targeted object must match this

TriggeredObjects:
- `Source` - The targeting card
- `Target` - The targeted object

# Championed
Goes off when a creature is championed.

Parameters:
- `ValidCard` - The card being exiled for championing must match this
- `ValidSource` - The champion card that is being played must match this

TriggeredObjects:
- `Championed` - The champion-exiled card
- `Card` - The championing card

# ChangesController
Goes off when a card changes controller.

Parameters:
- `ValidCard` - The card whose controller changes must match this
- `ValidOriginalController` - The player who originally controlled the card must match this

TriggeredObjects:
- `Card` - The card whose controller changes

# ChangesZone
Goes off whenever a card changes zone.

Parameters:
- `ValidCard` - The card that was moved must match this for the trigger to go off
- `Origin` - The card must be moved from this zone for the trigger to go off. (Defaults to "Any")
- `Destination` - The card must be moved to this zone for the trigger to go off. (Defaults to "Any")

TriggeredObjects:
- `Card` - The card that was moved
- `CardLKI`

# ChangesZoneAll

# Clashed
Goes off whenever a player has clashed, regardless of whether you won or not.

Parameters:
- `ValidPlayer` - Who clashed
- `Won` - True if the player must have won, false otherwise

# Combat

## AttackerBlocked
Goes off when at least one creature becomes blocked. It goes off only once (no matter how many blockers there are) right after the declare blockers step.

Parameters:
- `ValidCard` - The attacking creature must match this for the trigger to go off
- `ValidBlocker` - The blocking creature must match this for the trigger to go off

TriggeredObjects:
- `Attacker` - The card of the attacking creature
- `Blocker` - The card of the blocking creaure
- `NumBlockers` - The number of things blocking the attacker

## AttackerBlockedOnce

## AttackerBlockedByCreature

## AttackerUnblocked
Goes off when a creature attacks and is not blocked, right after the declare blockers step.

Parameters:
- `ValidCard` - The attacking creature must match this for the trigger to go off

TriggeredObjects:
- `Attacker` - The card of the attacking creature

## AttackerUnblockedOnce

## AttackersDeclared
Goes off after attackers are declared, if any attackers were declared, once a combat only.

Parameters:
- `AttackingPlayer` - The attacking player must match this
- `AttackedTarget` - One of the game entities in TriggeredAttackedTarget must match this

TriggeredObjects:
- `Attackers` - Collection of attacking creatures
- `AttackingPlayer` - The targeted object
- `AttackedTarget` - Collection of game entities that each attacker is attacking

## Attacks
Goes off when a creature attacks. That is, it goes off once for each creature that attacks during your each combat phase (Right after the declare attackers step).

Parameters:
- `ValidCard` - The attacking creature must match this for the trigger to go off
- `Alone` - If this is True, the trigger will only go off if the creature attacks alone

TriggeredObjects:
- `Attacker` - The card of the attacking creature

## BlockersDeclared
Goes off after blockers are declared if there are any, once in a combat only

Parameters:
- `Blockers` - Collection of all blockers
- `Attackers` - Collection of all attackers

## Blocks
Blocks-triggers go off when a creature blocks.

Parameters:
- `ValidCard` - The blocking creature must match this
- `ValidBlocked` - The creature being blocked must match this

TriggeredObjects:
- `Attacker` - The card of the attacking creature
- `Blocker` - The card of the blocking creaure

# CounterAdded / CounterRemoved
These triggers go off when a counter is added to / removed from a card.

Parameters:
- `ValidCard` - The card getting the counter must match this for the trigger to go off
- `CounterType` - The counter must be of this type for the trigger to go off
- `NewCounterAmount` - The counter amount AFTER the trigger fires must be this. NOTE: only available to CounterRemoved at the moment

TriggeredObjects:
- `Card` - the card the counter was added to

# Countered
Goes off when a spell or ability is countered.

Parameters:
- `ValidCard` - The host card of the spell/ability that was countered must match this
- `ValidPlayer` - The player that cast/activated the spell/ability that was countered must match this
- `ValidCause` - The host card of the spell/ability that did the countering must match this

TriggeredObjects:
- `Card` - The host card of the spell/ability that was countered
- `Player` - The player that cast/activated the spell/ability that was countered
- `Cause` - The host card of the spell/ability that did the countering

# Cycled
Cycled-triggers simply go off whenever you cycle a card.

Parameters:
- `ValidCard` - The card that was cycled must match this

TriggeredObjects:
- `Card` - The card that was cycled

# Damage

## DamageAll

## DamageDone
DamageDone-triggers go off whenever any source deals damage to any target.

Parameters:
- `ValidSource` - The source of the damage must match this
- `ValidTarget` - The target of the damage must match this
- `CombatDamage` - If set to true, the trigger will only go off if the damage dealt was combat damage.If set to false, it will only go off if it wasn't combat damage.. If omitted, it will go off either way
- `DamageAmount` - Specifies how much damage must be done for the trigger to go off. It takes the form "<operator><operand>"

TriggeredObjects:
- `Source` - The source of the damage
- `Target` - The target of the damage
- `DamageAmount` - The amount of damage dealt(integer)

## DamageDoneOnce
Goes off once for every game entity that recieves damage in combat.

Parameters:
- `ValidSource` - One or more of the game entities that dealt the damage must match this
- `ValidTarget` - The game entity that recieved damage must match this

TriggeredObjects:
- `Sources` - A collection of the game entities that dealt the damage
- `Target` - The game entity that received damage

## DamageDealtOnce
Goes off \*once\* for each creature that deals damage

Parameters:
- `ValidTarget` - The game entity that recieves damage must match this
- `ValidSource` - The card that dealt damage must match this

TriggeredObjects:
- `Target` - The game entity that recieves damage
- `Source` - The card that dealt damage

## ExcessDamage

# Destroyed
Goes off when a permanent is destroyed.

Parameters:
- `ValidCard` - The card that was destroyed must match this
- `ValidCauser` - The player that activated the spell/ability that destroyed the card must match this

TriggeredObjects:
- `Card` - The card that was destroyed
- `Causer` - The player that activated the spell/ability that destroyed the card

# Devoured
Goes off when a creature is sacrificed for a Devour creature.

Parameters:
- `ValidDevoured` - The devoured creature must match this

TriggeredObjects:
- `Devoured` - The devoured creature

# Discarded
Discarded-triggers go off whenever a card is discarded from a players hand.

Parameters:
- `ValidPlayer` - The player who discarded the card must match this
- `ValidCard` - The discarded card must match this
- `ValidCause` - The card that caused the player to discard must match this

TriggeredObjects:
- `Card` - The discarded card

# Drawn
Goes off when a player draws a card.

Parameters:
- `ValidCard` - The drawn card must match this

TriggeredObjects:
- `Card` - The card that was drawn
- `Player` - The player that drew the card

# Evolved
Goes off when a creature gets a +1/+1 counter from evolving.

Parameters:
- `ValidCard` - The card that got the counter must match this

TriggeredObjects:
- `Card` - The card that got the counter

# FlippedCoin
Goes off when a player flips a coin.

Parameters:
- `ValidPlayer` - The player who flipped the coin must match this
- `ValidResult` - If this parameter is "Win", the player must win the flip

TriggeredObjects:
- `Player` - The player who flipped the coin

# LandPlayed
Goes off when a land is played.

Parameters:
- `ValidCard` - The played card must match this

TriggeredObjects:
- `Card` - The card that was played

# LifeGained / LifeLost
These triggers go off on when a player either gains or loses life.

Parameters:
- `ValidPlayer` - The player who gained or lost life must match this

TriggeredObjects:
- `Player` - The player that gained/lost life
- `LifeAmount` - The amount of life lost/gained (integer)

# LosesGame
Goes off when a player loses the game.

Parameters:
- `ValidPlayer` - The player who lost the game must match this

TriggeredObjects:
- `Player` - The Player who lost the game

# NewGame
Goes off once at the start of each game, after mulligans.

# PayCumulativeUpkeep / PayEcho
Goes off when a player pays or doesn't pay the cumulative upkeep / echo cost for a card.

Parameters:
- `Paid` - Whether the player must have paid the cost
- `ValidCard` - The card that has the cost must match this

TriggeredObjects:
- `Card` - The card that has the cost
- `PayingMana` - A string representing the mana spent

# Phase
Phase-triggers go off at specific points in the turns.

Parameters:
- `Phase` - The phase during which the trigger should go off
- `ValidPlayer` - The player who's turn it should be

TriggeredObjects:
- `Player` - The player whose turn it is

# PhaseIn / PhaseOut
Goes off when a permanent phases in or out.

Parameters:
- `ValidCard` - The card phasing in or out must match this

TriggeredObjects:
- `Card` - The card phasing in or out

# PlanarDice
Goes off when the planar dice is rolled in a Planechase game.

Parameters:
- `ValidPlayer` - The player that rolled the dice must match this
- `Result` - The dice must roll this. Blank,Chaos or Planeswalk

TriggeredObjects:
- `Player` - The player that rolled the dice

# PlaneswalkedTo / PlaneswalkedFrom
These triggers go off when a player planeswalks to or away from one or  more planes.

Parameters:
- `ValidCard` - One of the planes must match this

TriggeredObjects:
- `Cards` - A collection of all the cards planeswalked to or from

# Sacrificed
Sacrificed-triggers go off whenever a player sacrifices a permanent.

Parameters:
- `ValidPlayer` - The player who sacrificed the card must match this
- `ValidCard` - The sacrificed card must match this

TriggeredObjects:
- `Card` - The card that was Sacrificed

# Scry
Goes off after a player has scryed and put the card(s) in the proper place.

Parameters:
- `ValidPlayer` - The player that scryed must match this

TriggeredObjects:
- `Player` - The player that scryed

# SearchedLibrary
Goes off when a player searches a library.

Parameters:
- `ValidPlayer` - The player searching must match this
- `SearchOwnLibrary` - If true, the player must be searching his or her own library

TriggeredObjects:
- `Player` - The player searching

# SetInMotion
Goes off when an Archenemy Scheme is set in motion.

Parameters:
- `ValidCard` - The scheme card that is set in motion must match this

TriggeredObjects:
- `Scheme` - The scheme card that is set in motion

# Shuffled
Goes off whenever a player shuffles his/her library.

Parameters:
- `ValidPlayer` - The player who's turn it should be

TriggeredObjects:
- `Player` - The player whose turn it is

# SpellCast / AbilityCast / SpellAbilityCast
These triggers go off whenever a spell,ability or either respectively is cast by either player.

Parameters:
- `ValidActivatingPlayer` - The player who activated the ability/spell must match this. (NOTE: For spells, the activator and controller are the same. They usually the same for abilities too, with the exception being abilities that can be activated by any player)
- `ValidCard` - The card the cast spell or ability originates from must match this
- `TargetsValid` - If this parameter is present, the spell or ability must be targeted and at least one of it's targets must match this

TriggeredObjects:
- `Card` - The card that the cast spell or ability originates from
- `SpellAbility` - The SpellAbility object
- `Player` - The player that controls the card that the cast spell or ability originates from
- `Activator` - The player that activated the ability

# Taps / Untaps
These triggers go off when a permanent taps or untaps.

Parameters:
- `ValidCard` - The card that taps or untaps must match this

TriggeredObjects:
- `Card` - The card that was tapped/untapped

# TapsForMana
Goes off when a land is tapped for a mana ability.

Parameters:
- `ValidCard` - The card that taps

TriggeredObjects:
- `Card` - The card that was tapped
- `Player` - the payer that did the tappin
- `Produced` - a String of the Mana produced by this tapping

# Transformed
Goes off when a card changes state from Original to Transformed or vice versa. (But not between any other 2 states)

Parameters:
- `ValidCard` - The card that changes state must match this

TriggeredObjects:
- `Transformer` - The card that changes state

# TurnFaceUp
Goes off when a card changes state from FaceDown to Original.

Parameters:
- `ValidCard` - The card that changes state must match this

TriggeredObjects:
- `Card` - The card that changes state

# Vote
Goes off when a vote is called for, after all votes are cast.

Parameters:
- `OtherVoters` - A collection of every player who voted, EXCEPT the controller of the trigger's host card